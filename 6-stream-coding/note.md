# Chapter 6 스트림 코딩
## 6-1 스트림의 중요성 발견

Node.js와 같은 이벤트 기반 플랫폼에서 I/O를 처리하는 가장 효율적인 방법은 스트림 방식이다.

그 이유는 다음과 같다.

1. 효율성 관점
1) 공간 효율성: 버퍼의 사이즈가 적어도 괜찮음
2) 시간 효율성: 각 청크에 대한 작업이 비동기적으로 이루어짐. 이는 Node.js에 의해 병렬적으로 처리 가능하기에, 한 파일을 직렬적으로 모두 처리하는 버퍼링 방식보다 빠름.
   ![](https://velog.velcdn.com/images/bcj0114/post/25994ad2-de6a-441e-b111-e74e1582218a/image.png)

2. 조립성
   `pipe()` 함수를 통해 스트림을 레고 처럼 간단하게 추가하고 결합할 수 있다. 이를 통해, 재사용성, 깜끔하고 모듈화된 코드 작성 가능해짐.

## 6-2 스트림 시작하기

### 6-2-1 스트림 해부
- Node.js의 모든 스트림은 네 가지 기본 추상 클래스 중 하나의 구현이다.
    - Readable
    - Writable
    - Duplex
    - Transform
- 각 스트림 클래스는 EventEmitter의 인스턴스이다.
    - 스트림은 여러 유형의 이벤트를 생성할 수 있다.
- 바이너리 데이터뿐만 아니라 거의 모든 JavaScript의 값을 처리할 수 있다.
    - Binary 모드: 버퍼 또는 문자열과 같은 청크 형태로 데이터를 스트리밍
    - 객체 모드: 데이터를 일련의 개별 객체로 스트리밍

### 6-2-2 Readable 스트림
- Readable 스트림은 데이터 소스를 나타낸다.
- Readable 스트림이 데이터를 수신하는 방법은 다음 두 가지이다.
    - non-flowing
    - flowing

#### non-flowing 모드(or pause 모드)
- 'readable' 이벤트를 리스터에 연결하고, 루프에서 내부 버퍼가 비워질 때까지 데이터를 계속 읽음.
    - readable 이벤트: 스트림에 읽을 수 있는 새로운 데이터가 있다는 것을 나타냄
- read() 함수를 사용하여 수행
    - read() 함수: 내부 버퍼에서 동기적으로 데이터를 읽어 Buffer 객체 반환. 읽을 데이터가 없다면 null 반환
    - Buffer 객체: 데이터 청크를 나타내는 객체
      ```javascript
      readable.read([size])
      ```
- 스트림에서 읽기를 위한 기본 패턴

#### flowing 모드
- 'data' 이벤트를 리스터에 연결하는 방식
- read() 함수를 사용하지 않음
- non-flowing 모드에 비해 데이터 흐름 제어 유연성이 떨어짐
- 기본이 non-flowing 모드이므로 활성화하려면 data 이벤트를 리스너에 연결하거나, resume() 함수를 명시적으로 호출. pause() 함수를 호출하면 스트림이 다시 non-flowing으로 전환.

#### 반복가능자(iterables)에서 Readable 스트림 얻기
> ___메모리에서 큰 배열을 인스턴화하지 말 것.___ 이와 관련되어 [9장. 행위 설계 패턴](9장 공부 후 해당 링크 추가할 것)에서 살펴볼 것
